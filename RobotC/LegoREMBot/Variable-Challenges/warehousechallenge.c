#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// im going to blow my head off with a shotgun

// movement script (handles turning and general translation)
void move(char* dirorstraight, int l, int s, bool ua) {
	if (dirorstraight == "straight") { // straight movement
		motor(motorB) = s;
		motor(motorC) = s;
	}
	else if (dirorstraight == "left") { // left turn movement
		motor(motorB) = s;
		motor(motorC) = -s;
	}
	else if (dirorstraight == "right") { // right turn movement
		motor(motorB) = -s;
		motor(motorC) = s;
	}
	else if (dirorstraight == "back") { // backwards movement
		motor(motorB) = -s;
		motor(motorC) = -s;
	}

	if (ua == true) { // if ua is true adjust delay for angle (degree input)
		delay((16.45 * (((s-50)*-1)+50)/100)*l); // calc
	}

	else if (ua == false) { // if ua is false don't use angle
		delay(l); // delay
	}
}

int lines; // amount of lines counted
int finalLines; // the line counter for the final
int debounce = 10; // set the debounce time

void updateDisplay(int add=0) {
	lines += add;

	displayTextLine(1, "light=%d", SensorValue[S3]);
	displayTextLine(2, "sonar=%d", SensorValue[S4]);
	displayTextLine(4, "lines=%d", lines);
}

// function to handle the big cell's on the bottom of the screen
void bigCellLower() {
	while(SensorValue[S3] > 50) { // repeat until black line
		motor[motorB] = 40;
		motor[motorC] = 40;
		delay(20);
		updateDisplay();
	}
	updateDisplay(1); // add 1 to lines because it hit a line
	motor[motorB] = 0;
	motor[motorC] = 0;
	delay(300);
}

void bigCellUpper() {
	for(int i=0; i<2; i++) {
		while(SensorValue[S3] > 50) { // repeat until black line
			motor[motorB] = 40;
			motor[motorC] = 40;
			delay(20);
			updateDisplay();
		}
		updateDisplay(1); // add 1 to lines because it hit a line
		motor[motorB] = 0;
		motor[motorC] = 0;
		delay(300);

		// prepare for second time
		motor[motorB] = 40;
		motor[motorC] = 40;
		delay(150);
	}
}

void junction() {
	while(SensorValue[S4] > 40) {
		motor[motorB] = 40;
		motor[motorC] = 40;
		delay(20);

		if(debounce > 10 && SensorValue[S3] < 70) {
			updateDisplay(1);
			debounce = 0;
		} else {
			debounce += 1;
		}
	}

	motor[motorB] = 0;
	motor[motorC] = 0;
	delay(300);
}

void final() {
	while(finalLines < 4) {
		motor[motorB] = 40;
		motor[motorC] = 40;
		delay(20);

		if(debounce > 10 && SensorValue[S3] < 50) {
			updateDisplay(1);
			debounce = 0;
			finalLines++;
		} else {
			debounce += 1;
		}
	}
}

task main() { // sequence
	move("straight", 900, 40, false); // start away from zone
	bigCellLower();
	move("left", 93, 40, true);
	junction();
	move("right", 92, 40, true);
	move("back", 150, 40, false);
	bigCellUpper();
	move("straight", 1000, 40, false);
	move("right", 93, 40, true);
	junction();
	move("left", 93, 40, true);
	bigCellUpper();
	move("back", 150, 40, false);
	move("straight", 1000, 40, false);
	move("left", 93, 40, true);
	junction();
	move("right", 92, 40, true);
	bigCellUpper();
	move("straight", 1000, 40, false);
	move("right", 90, 40, true);
	junction();
	move("right", 90, 40, true);
	final(); // last long stretch
	move("straight", 4000, 40, false);
	motor[motorB] = 0;
	motor[motorC] = 0;
	delay(200);
	move("back", 3000, 40, false);
	move("right", 90, 40, true);
	junction();
	move("right", 90, 40, true);
	move("straight", 2000, 40, false);
}
